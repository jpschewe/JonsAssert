*** java.g.orig	Fri Dec 24 15:59:13 1999
--- java.g	Fri Dec 24 15:55:48 1999
***************
*** 1,3 ****
--- 1,19 ----
+ header {
+ /*
+   This file is licensed through the GNU public License.  Please read it.
+   Basically you can modify this code as you wish, but you need to distribute
+   the source code for all applications that use this code.
+ 
+   I'd appreciate comments/suggestions on the code schewe@tcfreenet.org
+ */
+ package org.tcfreenet.schewe.Assert;
+ 
+ import java.util.Enumeration;
+ import java.util.Vector;
+ 
+ //import antlr.JavaToken;
+ 
+ }
  /** Java 1.1 Recognizer Grammar
   *
   * Run 'java JavaRecognizer <directory full of java files>'
***************
*** 55,63 ****
  	PARAMETERS; PARAMETER_DEF; LABELED_STAT; TYPECAST; INDEX_OP; 
  	POST_INC; POST_DEC; METHOD_CALL; EXPR; ARRAY_INIT; 
  	IMPORT; UNARY_MINUS; UNARY_PLUS; CASE_GROUP; ELIST; FOR_INIT; FOR_CONDITION; 
! 	FOR_ITERATOR; EMPTY_STAT;
  }
! 	
  // Compilation Unit: In Java, this is a single file.  This is the start
  //   rule for this parser
  compilationUnit
--- 71,103 ----
  	PARAMETERS; PARAMETER_DEF; LABELED_STAT; TYPECAST; INDEX_OP; 
  	POST_INC; POST_DEC; METHOD_CALL; EXPR; ARRAY_INIT; 
  	IMPORT; UNARY_MINUS; UNARY_PLUS; CASE_GROUP; ELIST; FOR_INIT; FOR_CONDITION; 
! 	FOR_ITERATOR; EMPTY_STAT; JAVADOC_OPEN; JAVADOC_CLOSE; POST_CONDITION; PRE_CONDITION;
! 	ASSERT_CONDITION; INVARIANT_CONDITION; CONDITION; MESSAGE;
  }
! 
! // Define some helper methods
! {
!   private static Vector _invariants = new Vector();
!     
!   private void addInvariants(Vector invariants) {
!     if(invariants != null) {
!       System.out.println("Parser: got invariants#");
!       Enumeration iter = invariants.elements();
!       while(iter.hasMoreElements()) {
!         Token ivc = (Token)iter.nextElement();
!         System.out.println(":" + ivc + ":");
!         _invariants.addElement(ivc);
!       }
!       System.out.println("#");
!     }
!   }
! 
!   private void clearInvariants() {
!     _invariants = new Vector();
!   }
!   
! }
! 
  // Compilation Unit: In Java, this is a single file.  This is the start
  //   rule for this parser
  compilationUnit
***************
*** 71,81 ****
  
  		// Wrapping things up with any number of class or interface
  		//    definitions
! 		( typeDefinition )*
  
  		EOF!
  	;
  
  
  // Package statement: "package" followed by an identifier.
  packageDefinition
--- 111,130 ----
  
  		// Wrapping things up with any number of class or interface
  		//    definitions
! 		( assertTypeDefinition )*
  
  		EOF!
  	;
  
+ assertTypeDefinition
+ 	{ Vector invTokens = null; }
+ 	: (JAVADOC_OPEN invTokens=invariantConditions JAVADOC_CLOSE)? typeDefinition
+ 	{ addInvariants(invTokens); }
+ 	;
+ 
+ invariantConditions returns [Vector v]
+ 	{ v=new Vector(); }	: ( iv:INVARIANT_CONDITION { v.addElement(iv); } )*
+         ;
  
  // Package statement: "package" followed by an identifier.
  packageDefinition
***************
*** 220,230 ****
  // That's about it (until you see what a field is...)
  classBlock
  	:	LCURLY!
! 			( field | SEMI )*
  		RCURLY!
  		{#classBlock = #([OBJBLOCK, "OBJBLOCK"], #classBlock);}
  	;
  
  // An interface can extend several other interfaces...
  interfaceExtends
  	:	(
--- 269,288 ----
  // That's about it (until you see what a field is...)
  classBlock
  	:	LCURLY!
! 			( assertfield | SEMI )*
  		RCURLY!
  		{#classBlock = #([OBJBLOCK, "OBJBLOCK"], #classBlock);}
  	;
  
+ assertfield :
+ 	    (JAVADOC_OPEN (ASSERT_CONDITION)* JAVADOC_CLOSE)? field
+ 	    //{ System.out.println("Parser: Got assert condition"); }
+ 	    ;
+ 
+ prePost : (POST_CONDITION | PRE_CONDITION)
+ 	{ System.out.println("Parser: Got a pre or post condition"); }
+ 	;
+ 
  // An interface can extend several other interfaces...
  interfaceExtends
  	:	(
***************
*** 947,955 ****
--- 1005,1043 ----
  		{$setType(Token.SKIP); newline();}
  	;
  
+ // Javadoc comments
+ JAVADOC_OPEN
+ 	: "/**"
+ 	{
+ 	  //System.out.println("java: got start of javadoc comment #" + text + "#");
+ 	  Main.selector.push(Main.assertLexer);
+ 	}
+ 	;
+ 
+ //JD_COMMENT
+ //	    :	"/**"
+ //		    (	options {
+ //				    generateAmbigWarnings=false;
+ //			    }
+ //		    :
+ //			  { LA(2)!='/' }? '*'
+ //		    |	'\r' '\n'		{newline();}
+ //		    |	'\r'			{newline();}
+ //		    |	'\n'			{newline();}
+ //		    |	~('*'|'\n'|'\r')
+ //		    )*
+ //		    "*/"
+ //		  {
+ //			  $setType(Token.SKIP);			
+ //			  System.out.println("Got a javadoc comment #" + text + "#");
+ //		  }
+ //
+ //	    ;
+ 
  // multiple-line comments
  ML_COMMENT
  	:	"/*"
+ 		~'*'
  		(	/*	'\r' '\n' can be matched in one alternative or by matching
  				'\r' in one iteration and '\n' in another.  I am trying to
  				handle any flavor of newline that comes in, but the language
***************
*** 1098,1100 ****
--- 1186,1190 ----
  	:	'f'|'F'|'d'|'D'
  	;
  
+ 
+ 	
