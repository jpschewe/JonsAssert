/*
  This file is meant to let others know how I intend to instrument files so
  that they know what types of method names may cause problems and to ease in
  debugging the code that is generated.  The code generated isn't exactly what
  I have here, but it should be close.

  remember only to check invariants on public instance methods, protected methods, constructor exit

  Replace all of the package names '.' with '_'

  All variables created here will have jps__ in front of them except.

  invariants are ANDed with super class
  preconditions are ORed with super class
  postconditions are ANDed with super class
  This puts the burden on the person using the instrumented method rather than the person writing the method.

  Each time a method is called it is "locked".  When a method is called and it
  is ready locked it returns true immediatly to avoid infinite recursion.

*/

//before
public Object methodFoo(Object param1) {
  return param1;
}

//after
public Object methodFoo(Object param1) {
  if(!jps__<packageName>_<className>_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  if(!jps__<packageName>_<className>_check<methodName>PreConditions(param1, param2, ...)) {
    AssertTools.preConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
  final Object jps__retVal<classname> = b;
    
  if(!jps__<packageName>_<className>_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  if(!jps__<packageName>_<className>_check<methodName>PostConditions(jps__retVal<classname>, param1, ...)) {
    AssertTools.postConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
  return jps__retVal<classname>;

}


/**
   Logic:  if(!super preconditions) {
              return false;
           }
           if( !AND(interface preconditions) ) {
             return false;
           }
           return AND(pre condtitions for this class);
              
**/
protected boolean jps__<packageName>_<methodName>_check<methodname>PostConditions(jps__retVal, param1, ...) {

  /* Just like check checkPreconditions, except that the superclass conditions
    as ANDed rather then ORed. */

  // AND, as soon as a false is seen, return false, looking up superclasses and interfaces
  
  if(! ((Boolean)retVal).booleanValue()) {
    return false;
  }

}

/**
   Logic:  if(super preconditions) {
              return true;
           }
           if( OR(interface preconditions) ) {
             return true;
           }
           return AND(pre condtitions for this class);
              
**/
protected boolean jps__<packageName>_<methodName>_check<methodname>PreConditions(param1, param2, ...) {
  Class thisClass;
  try {
    String className = "<fill in class name>";
    thisClass = Class.forName(className);
  }
  catch(ClassNotFoundException cnfe) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("Got error getting the class object for class " + className + " " + cnfe);
  }

  Class[] methodArgs = new Class[0];
  Method superMethod = org.tcfreenet.schewe.Assert.AssertTools.findSuperMethod(thisClass, "check<methodname>PreConditions", methodArgs);

  if(superMethod != null) {
    //invoke it, bail on exceptions
    Object[] args = new Object[0];
    try {
      retVal = superMethod.invoke(this, args);
    }
    catch(IllegalAccessException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("Not enough access executing superClass check<methodName>PreConditions: " + iae.getMessage());
    }
    catch(IllegalArgumentException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("IllegalArgument executing superClass check<methodName>PreConditions: " + iae.getMessage());
      //should never see, internal error
    }
    catch(java.lang.reflect.InvocationTargetException ite) {
      ite.getTargetException().printStackTrace();
    }
  }

  if(retVal == null) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got null check<methodName>PreConditions");
  }
  else if(! (retVal instanceof Boolean) ) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got something odd from check<methodName>Preconditions: " + retVal.getClass());
  }


  //[jpschewe:20000213.1603CST] FIX do interface pre conditions first and keep track of which interface they're from

  
  // OR, as soon as a true is seen, return true;  
  if(((Boolean)retVal).booleanValue()) {
    return true;
  }

  //for <condition> (conditions)
  if(! <condition> ) {
    org.tcfreenet.schewe.Assert.AssertionViolation av = new org.tcfreenet.schewe.Assert.AssertionViolation((<message> != null ? <message> : "") + "\n" + <condition>);
    org.tcfreenet.schewe.Assert.AssertTools.setCurrentAssertionViolation(av);
    
    return false;
  }
  //end for
  
  return true;
}


/**
   Logic:  if(!super invariants) {
              return false;
           }
           if( !AND(interface invariants) ) {
             return false;
           }
           return AND(invariants for this class);
              
**/
protected boolean jps__<packageName>_<methodName>_checkInvariant() {
  Class thisClass;
  try {
    String className = "<fill in class name>";
    thisClass = Class.forName(className);
  }
  catch(ClassNotFoundException cnfe) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("Got error getting the class object for class " + className + " " + cnfe);
  }
  
  Class[] methodArgs = new Class[0];
  Method superMethod = org.tcfreenet.schewe.Assert.AssertTools.findSuperMethod(thisClass, "checkInvariant", methodArgs);

  if(superMethod != null) {
    //invoke it, bail on exceptions
    Object[] args = new Object[0];
    try {
      retVal = superMethod.invoke(this, args);
    }
    catch(IllegalAccessException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("Not enough access executing superClass checkInvariant: " + iae.getMessage());
    }
    catch(IllegalArgumentException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("IllegalArgument executing superClass checkInvariant: " + iae.getMessage());
      //should never see, internal error
    }
    catch(java.lang.reflect.InvocationTargetException ite) {
      ite.getTargetException().printStackTrace();
    }
  }

  if(retVal == null) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got null checkInvariant");
  }
  else if(! (retVal instanceof Boolean) ) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got something odd from checkInvariant: " + retVal.getClass());
  }

  if(!((Boolean)retVal).booleanValue()) {
    return false;
  }
  

  //[jpschewe:20000116.1749CST] FIX still need to add to this do interface
  //invariants first and keep track of which interface they're from
  
  //for <condition> (conditions)
  if(! <condition> ) {
    org.tcfreenet.schewe.Assert.AssertionViolation av = new org.tcfreenet.schewe.Assert.AssertionViolation((<message> != null ? <message> : "") + "\n" + <condition>);
    org.tcfreenet.schewe.Assert.AssertTools.setCurrentAssertionViolation(av);
    
    return false;
  }

  return true;
}


//preconditions on constructor
//Before
/**
   @pre (i > 0)
   @pre (checkValue(i))
**/
public Test(int i) {
  System.out.println("in constructor " + i);
}

//After
/**
   @pre (i > 0)
   @pre (checkValue(i))
**/
public Test (int i) {
// -- start output from generatePreCondtitionCall 
  this(i, new JPS_<packageName>_Test_AssertDummy0(i), true, ...);
  //standard check invariant call
  if(!jps__<packageName>_Test_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  //standard post condition call for void method
  if(!jps__<packageName>_Test_checkTestPostConditions(i)) {
    AssertTools.postConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
}
class JPS_<packageName>_Test_AssertDummy0 {
  public JPS_<packageName>_Test_AssertDummy0(int i) {
    //Standard precondition call    
    if(!jps__<packageName>_Test_checkTestPreConditions(i)) {
      AssertTools.preConditionFailed(AssertTools.getCurrentAssertionViolation());
    }
  }
}
private Test(int i, JPS_<packageName>_Test_AssertDummy0 ad, <some number of extra boolean parameters to uniquify signature>) {
// -- end output from generatePreConditionCall
  System.out.println("in constructor " + i);
}
//Standard preCondition and postCondition methods here

  

//ideas for implemented interface checks

//when an implemented interface is found:
/**
  Given the name of an interface return a List of possible full names.  This
  is a List because of the problems of finding an Interface with star imports
  and looking in the current package and for inner classes.
**/
List getFullInterfaceName(final String interfaceName,
                          final AssertClass implementingClass) {
  List retVal = new Vector();
  if(interfaceName.indexOf('.') == -1) { //definatly a short class name
    String fullInterfaceName = findInterfaceInImports(interfaceName);
    if(fullInterfaceName != null) { //found it!
      retVal.add(fullInterfaceName);
      return retVal;
    }
    else {
      retVal.add(interfaceName); // default package
      if(implementingClass.getPackageName() != null) {
        retVal.add(implementingClass.getPackageName() + "." + interfaceName); //Local or other class in same package
      }
      retVal.add(implementingClass.getFullName() + "$" + interfaceName); //Inner class
      if(starImports()) { // need to check each star import
        /* Walk the list of imports and for each star import do:
           retVal.add(starImport + "." + interfaceName); */
      }
      return retVal;
    }
  }
  else {
    //Whole other mess to figure out, need to figure out if it's already a full name or just an inner class
  }
}


//Before
public interface Interface {
  
  /**
     @pre (postCond(i) > 5)
  **/
  public boolean preCond(int i);

}

//After
public interface Interface {
  
  /**
     @pre (postCond(i) > 5)
  **/
  public boolean preCond(int i);

  static final public class JPS__<packageName>_<className>_AssertClass implements Interface {
    private Class[] _interfaceCache;
    private Interface _delegate;
    public jps__<packageName>_<className>_AssertClass(final Interface delegate) {
      _delegate = delegate;
      //Do some caching
      final Class[] interfaces = Interface.class.getInterfaces();
      _interfaceCache = new Class[interfaces.length];
      if() {
        
      } else {
        _interfaceCache[i] = AssertTools.NO_CLASS;
      }
      
    }

    public boolean preCond(int i) {
      return _delegate.preCond(i);
    }

    public boolean checkpreCondPreConditions(int i) {
      if(! (postCond(i) > 5) ) {
        return false;
      }
      //Need to check super interfaces
      final Class interfaces = Interface.class.getInterfaces();
      for(int i=0; i<interfaces.length; i++) {
        if(AssertTools.classForname()) {
          
        } else {
          _interfaceCache[i] = 
        }
      }
      
      return true;
    }
    public boolean checkpreCondPostConditions(boolean jps__retVal, int i) {
      return true;
    }

  }
}

