/*
  This file is meant to let others know how I intend to instrument files so
  that they know what types of method names may cause problems and to ease in
  debugging the code that is generated.
  
  still need to check order of pre vs. invariant, or does it matter?

  remember only to check invariants on public instance methods, protected methods?, constructor exit

  Replace all of the package names '.' with '_'
*/
public Object methodFoo(Object param1) {
  if(!__<packageName>_<className>_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  if(!__<packageName>_<className>_check<methodName>PreConditions(param1, param2, ...)) {
    AssertTools.preConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
  final Object __oldParam1 = param1;


  /* was return b; */
  final Object __retVal = b;
  if(!__<packageName>_<className>_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  if(!__<packageName>_<className>_check<methodName>PostConditions(__retVal, __oldParam1, param1, ...)) {
    AssertTools.postConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
  return __retVal;
}

protected boolean __<packageName>_<methodName>_check<methodname>PostConditions(__retVal, oldParam1, param1, ...) {
    // OR, as soon as a true is seen, return true

    // do interface post conditions first and keep track of which interface they're from
    
    if(((Boolean)retVal).booleanValue()) {
        return true;
    }

}

protected boolean __<packageName>_<methodName>_check<methodname>PreConditions(param1, param2, ...) {
    // AND, as soon as a false is seen, return false;

    // do interface pre conditions first and keep track of which interface they're from
    
    if(!((Boolean)retVal).booleanValue()) {
        return false;
    }
}

  
protected boolean __<packageName>_<methodName>_checkInvariant() {
  Class thisClass;
  try {
    String className = "<fill in class name>";
    thisClass = Class.forName(className);
  }
  catch(ClassNotFoundException cnfe) {
    AssertTools.internalError("Got error getting the class object for class " + className + " " + cnfe);
  }
  
  Class[] methodArgs = new Class[0];
  Method superMethod = AssertTools.findSuperMethod(thisClass, "__checkInvariant", methodArgs);

  if(superMethod != null) {
    //invoke it, pass on exceptions
    Object[] args = new Object[0];
    try {
      retVal = superMethod.invoke(this, args);
    }
    catch(IllegalAccessException iae) {
      AssertTools.internalError("Not enough access executing super.__checkInvariant: " + iae.getMessage());
    }
    catch(IllegalArgumentException iae) {
      AssertTools.internalError("IllegalArgument executing super.__checkInvariant: " + iae.getMessage());
      //should never see, internal error
    }
    catch(java.lang.reflect.InvocationTargetException ite) {
      throw ite.getTargetException();
    }
  }

  if(retVal == null) {
    AssertTools.internalError("got null checkInvariant");
  }
  else if(! (retVal instanceof Boolean) ) {
    AssertTools.internalError("got something odd from checkInvariant: " + retVal.getClass());
  }

  if(!((Boolean)retVal).booleanValue()) {
    return false;
  }
  

  //[jpschewe:20000116.1749CST] still need to add to this do interface
  //invariants first and keep track of which interface they're from
  
  //for <condition> (conditions)
  if(<condition>) {
    AssertionViolation av = new AssertionViolation((<message> != null ? <message> : "") + "\n" + <condition>);
    AssertTools.setCurrentAssertionViolation(av);
    
    return false;
  }

  return true;
}

