/*
  This file is meant to let others know how I intend to instrument files so
  that they know what types of method names may cause problems and to ease in
  debugging the code that is generated.
  

  remember only to check invariants on public instance methods, protected methods, constructor exit

  Replace all of the package names '.' with '_'

  All variables created here will have _JPS_ in front of them except for __retVal and __old*

  invariants are ANDed with super class
  preconditions are ORed with super class
  postconditions are ANDed with super class
  This puts the burden on the person using the instrumented method rather than the person writing the method.
*/

//before
public Object methodFoo(Object param1) {
  return param1;
}

//after
public Object methodFoo(Object param1) {
  if(!__<packageName>_<className>_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  if(!__<packageName>_<className>_check<methodName>PreConditions(param1, param2, ...)) {
    AssertTools.preConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
  final Object __oldParam1 = param1;
  
  final Object __retVal<classname> = b;
    
  if(!__<packageName>_<className>_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  if(!__<packageName>_<className>_check<methodName>PostConditions(__retVal<classname>, __oldParam1, param1, ...)) {
    AssertTools.postConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
  return __retVal<classname>;

}


//[jpschewe:20000213.1555CST] FIX still need code, it's in CodeGenerator, copy it to here or from checkPreConditions
protected boolean __<packageName>_<methodName>_check<methodname>PostConditions(__retVal, oldParam1, param1, ...) {


    //[jpschewe:20000213.1603CST] FIX do interface post conditions first and keep track of which interface they're from
    
  // AND, as soon as a true is seen, return true
  if(! ((Boolean)retVal).booleanValue()) {
    return false;
  }

}


protected boolean __<packageName>_<methodName>_check<methodname>PreConditions(param1, param2, ...) {
  Class thisClass;
  try {
    String className = "<fill in class name>";
    thisClass = Class.forName(className);
  }
  catch(ClassNotFoundException cnfe) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("Got error getting the class object for class " + className + " " + cnfe);
  }

  //[jpschewe:20000213.1552CST] FIX need method parameters here, just the class objects
  Class[] methodArgs = new Class[0];
  Method superMethod = org.tcfreenet.schewe.Assert.AssertTools.findSuperMethod(thisClass, "check<methodname>PreConditions", methodArgs);

  if(superMethod != null) {
    //invoke it, bail on exceptions
    //[jpschewe:20000213.1552CST] FIX need parameters here, just the parameter names
    Object[] args = new Object[0];
    try {
      retVal = superMethod.invoke(this, args);
    }
    catch(IllegalAccessException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("Not enough access executing superClass check<methodName>PreConditions: " + iae.getMessage());
    }
    catch(IllegalArgumentException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("IllegalArgument executing superClass check<methodName>PreConditions: " + iae.getMessage());
      //should never see, internal error
    }
    catch(java.lang.reflect.InvocationTargetException ite) {
      ite.getTargetException().printStackTrace();
    }
  }

  if(retVal == null) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got null check<methodName>PreConditions");
  }
  else if(! (retVal instanceof Boolean) ) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got something odd from check<methodName>Preconditions: " + retVal.getClass());
  }


  //[jpschewe:20000213.1603CST] FIX do interface pre conditions first and keep track of which interface they're from

  // OR, as soon as a false is seen, return false;  
  if(((Boolean)retVal).booleanValue()) {
    return true;
  }

  //for <condition> (conditions)
  if(! <condition> ) {
    org.tcfreenet.schewe.Assert.AssertionViolation av = new org.tcfreenet.schewe.Assert.AssertionViolation((<message> != null ? <message> : "") + "\n" + <condition>);
    org.tcfreenet.schewe.Assert.AssertTools.setCurrentAssertionViolation(av);
    
    return false;
  }
  //end for
  
  return true;
}

  
protected boolean __<packageName>_<methodName>_checkInvariant() {
  Class thisClass;
  try {
    String className = "<fill in class name>";
    thisClass = Class.forName(className);
  }
  catch(ClassNotFoundException cnfe) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("Got error getting the class object for class " + className + " " + cnfe);
  }
  
  Class[] methodArgs = new Class[0];
  Method superMethod = org.tcfreenet.schewe.Assert.AssertTools.findSuperMethod(thisClass, "checkInvariant", methodArgs);

  if(superMethod != null) {
    //invoke it, bail on exceptions
    Object[] args = new Object[0];
    try {
      retVal = superMethod.invoke(this, args);
    }
    catch(IllegalAccessException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("Not enough access executing superClass checkInvariant: " + iae.getMessage());
    }
    catch(IllegalArgumentException iae) {
      org.tcfreenet.schewe.Assert.AssertTools.internalError("IllegalArgument executing superClass checkInvariant: " + iae.getMessage());
      //should never see, internal error
    }
    catch(java.lang.reflect.InvocationTargetException ite) {
      ite.getTargetException().printStackTrace();
    }
  }

  if(retVal == null) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got null checkInvariant");
  }
  else if(! (retVal instanceof Boolean) ) {
    org.tcfreenet.schewe.Assert.AssertTools.internalError("got something odd from checkInvariant: " + retVal.getClass());
  }

  if(!((Boolean)retVal).booleanValue()) {
    return false;
  }
  

  //[jpschewe:20000116.1749CST] FIX still need to add to this do interface
  //invariants first and keep track of which interface they're from
  
  //for <condition> (conditions)
  if(! <condition> ) {
    org.tcfreenet.schewe.Assert.AssertionViolation av = new org.tcfreenet.schewe.Assert.AssertionViolation((<message> != null ? <message> : "") + "\n" + <condition>);
    org.tcfreenet.schewe.Assert.AssertTools.setCurrentAssertionViolation(av);
    
    return false;
  }

  return true;
}


//preconditions on constructor
//Before
/**
   @pre (i > 0)
   @pre (checkValue(i))
**/
public Test(int i) {
  System.out.println("in constructor " + i);
}

//After
/**
   @pre (i > 0)
   @pre (checkValue(i))
**/
public Test (int i) {
// -- start output from generatePreCondtitionCall 
  this(i, new <packageName>_Test_AssertDummy0(i));
  //standard check invariant call
  if(!__<packageName>_Test_checkInvariant()) {
    AssertTools.invariantFailed(AssertTools.getCurrentAssertionViolation());
  }
  //standard post condition call for void method, except no old values
  if(!__<packageName>_Test_checkTestPostConditions(i)) {
    AssertTools.postConditionFailed(AssertTools.getCurrentAssertionViolation());
  }
}

private Test(int i, <packageName>_Test_AssertDummy0 ad) {
// -- end output from generatePreConditionCall
  System.out.println("in constructor " + i);
}
//Standard postCondition method here, except no old values
...
<EOF>
  class <packageName>_Test_AssertDummy0 {
    public <packageName>_Test_AssertDummy0(int i) {  
      // AND, as soon as a false is seen, return false;

      Object retVal = superMethod.invoke(i);
  
      if(!((Boolean)retVal).booleanValue()) {
        AssertTools.preConditionFailed(AssertTools.getCurrentAssertionViolation());
        //return false;
      }

      if(! (i > 0) ) {
        //AssertionViolation
        AssertTools.preConditionFailed(AssertTools.getCurrentAssertionViolation());
        //return false;
      }
      if(! checkValue(i) ) {
        //AssertionViolation
        AssertTools.preConditionFailed(AssertTools.getCurrentAssertionViolation());
        //return false;
      }

      //return true;
    }
  }


  

//ideas for implemented interface checks

//when an implemented interface is found:
/**
  Given the name of an interface return a List of possible full names.  This
  is a List because of the problems of finding an Interface with star imports
  and looking in the current package and for inner classes.
**/
List getFullInterfaceName(final String interfaceName,
                          final AssertClass implementingClass) {
  List retVal = new Vector();
  if(interfaceName.indexOf('.') == -1) { //definatly a short class name
    String fullInterfaceName = findInterfaceInImports(interfaceName);
    if(fullInterfaceName != null) { //found it!
      retVal.add(fullInterfaceName);
      return retVal;
    }
    else {
      retVal.add(interfaceName); // default package
      if(implementingClass.getPackageName() != null) {
        retVal.add(implementingClass.getPackageName() + "." + interfaceName); //Local or other class in same package
      }
      retVal.add(implementingClass.getFullName() + "$" + interfaceName); //Inner class
      if(starImports()) { // need to check each star import
        /* Walk the list of imports and for each star import do:
           retVal.add(starImport + "." + interfaceName); */
      }
      return retVal;
    }
  }
  else {
    //Whole other mess to figure out, need to figure out if it's already a full name or just an inner class
  }
}
