/*
 * ANTLR-generated file resulting from grammar assert.g
 * 
 * Terence Parr, MageLang Institute
 * ANTLR Version 2.6.1; 1989-1999
 */

/*
  This file is licensed through the GNU public License.  Please read it.
  Basically you can modify this code as you wish, but you need to distribute
  the source code for all applications that use this code.

  I'd appreciate comments/suggestions on the code schewe@tcfreenet.org
*/
package org.tcfreenet.schewe.Assert;


public interface AssertLexerTokenTypes {
	int EOF = 1;
	int NULL_TREE_LOOKAHEAD = 3;
	int BLOCK = 4;
	int MODIFIERS = 5;
	int OBJBLOCK = 6;
	int SLIST = 7;
	int CTOR_DEF = 8;
	int METHOD_DEF = 9;
	int VARIABLE_DEF = 10;
	int INSTANCE_INIT = 11;
	int STATIC_INIT = 12;
	int TYPE = 13;
	int CLASS_DEF = 14;
	int INTERFACE_DEF = 15;
	int PACKAGE_DEF = 16;
	int ARRAY_DECLARATOR = 17;
	int EXTENDS_CLAUSE = 18;
	int IMPLEMENTS_CLAUSE = 19;
	int PARAMETERS = 20;
	int PARAMETER_DEF = 21;
	int LABELED_STAT = 22;
	int TYPECAST = 23;
	int INDEX_OP = 24;
	int POST_INC = 25;
	int POST_DEC = 26;
	int METHOD_CALL = 27;
	int EXPR = 28;
	int ARRAY_INIT = 29;
	int IMPORT = 30;
	int UNARY_MINUS = 31;
	int UNARY_PLUS = 32;
	int CASE_GROUP = 33;
	int ELIST = 34;
	int FOR_INIT = 35;
	int FOR_CONDITION = 36;
	int FOR_ITERATOR = 37;
	int EMPTY_STAT = 38;
	int FINAL = 39;
	int ABSTRACT = 40;
	int JAVADOC_OPEN = 41;
	int JAVADOC_CLOSE = 42;
	int POST_CONDITION = 43;
	int PRE_CONDITION = 44;
	int ASSERT_CONDITION = 45;
	int INVARIANT_CONDITION = 46;
	int CONDITION = 47;
	int MESSAGE = 48;
	int LITERAL_package = 49;
	int SEMI = 50;
	int LITERAL_import = 51;
	int LBRACK = 52;
	int RBRACK = 53;
	int LITERAL_void = 54;
	int LITERAL_boolean = 55;
	int LITERAL_byte = 56;
	int LITERAL_char = 57;
	int LITERAL_short = 58;
	int LITERAL_int = 59;
	int LITERAL_float = 60;
	int LITERAL_long = 61;
	int LITERAL_double = 62;
	int IDENT = 63;
	int DOT = 64;
	int STAR = 65;
	int LITERAL_private = 66;
	int LITERAL_public = 67;
	int LITERAL_protected = 68;
	int LITERAL_static = 69;
	int LITERAL_transient = 70;
	int LITERAL_native = 71;
	int LITERAL_threadsafe = 72;
	int LITERAL_synchronized = 73;
	int LITERAL_volatile = 74;
	int LITERAL_class = 75;
	int LITERAL_extends = 76;
	int LITERAL_interface = 77;
	int LCURLY = 78;
	int RCURLY = 79;
	int COMMA = 80;
	int LITERAL_implements = 81;
	int LPAREN = 82;
	int RPAREN = 83;
	int ASSIGN = 84;
	int LITERAL_throws = 85;
	int COLON = 86;
	int LITERAL_if = 87;
	int LITERAL_else = 88;
	int LITERAL_for = 89;
	int LITERAL_while = 90;
	int LITERAL_do = 91;
	int LITERAL_break = 92;
	int LITERAL_continue = 93;
	int LITERAL_return = 94;
	int LITERAL_switch = 95;
	int LITERAL_throw = 96;
	int LITERAL_case = 97;
	int LITERAL_default = 98;
	int LITERAL_try = 99;
	int LITERAL_finally = 100;
	int LITERAL_catch = 101;
	int PLUS_ASSIGN = 102;
	int MINUS_ASSIGN = 103;
	int STAR_ASSIGN = 104;
	int DIV_ASSIGN = 105;
	int MOD_ASSIGN = 106;
	int SR_ASSIGN = 107;
	int BSR_ASSIGN = 108;
	int SL_ASSIGN = 109;
	int BAND_ASSIGN = 110;
	int BXOR_ASSIGN = 111;
	int BOR_ASSIGN = 112;
	int QUESTION = 113;
	int LOR = 114;
	int LAND = 115;
	int BOR = 116;
	int BXOR = 117;
	int BAND = 118;
	int NOT_EQUAL = 119;
	int EQUAL = 120;
	int LT = 121;
	int GT = 122;
	int LE = 123;
	int GE = 124;
	int LITERAL_instanceof = 125;
	int SL = 126;
	int SR = 127;
	int BSR = 128;
	int PLUS = 129;
	int MINUS = 130;
	int DIV = 131;
	int MOD = 132;
	int INC = 133;
	int DEC = 134;
	int BNOT = 135;
	int LNOT = 136;
	int LITERAL_this = 137;
	int LITERAL_super = 138;
	int LITERAL_true = 139;
	int LITERAL_false = 140;
	int LITERAL_null = 141;
	int LITERAL_new = 142;
	int NUM_INT = 143;
	int CHAR_LITERAL = 144;
	int STRING_LITERAL = 145;
	int NUM_FLOAT = 146;
	int WS = 147;
	int SL_COMMENT = 148;
	int ML_COMMENT = 149;
	int ESC = 150;
	int HEX_DIGIT = 151;
	int VOCAB = 152;
	int EXPONENT = 153;
	int FLOAT_SUFFIX = 154;
	int NEWLINE = 155;
}
